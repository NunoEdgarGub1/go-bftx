// Code generated by protoc-gen-go. DO NOT EDIT.
// source: saberservice.proto

package bfimports

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// The BFTX encryption transaction data structure (test version)
type BFTX_EncodeRequest struct {
	Bftxtrans  *BFTXTransaction      `protobuf:"bytes,1,opt,name=bftxtrans" json:"bftxtrans,omitempty"`
	Bftxconfig *BFTXEncryptionConfig `protobuf:"bytes,2,opt,name=bftxconfig" json:"bftxconfig,omitempty"`
}

func (m *BFTX_EncodeRequest) Reset()                    { *m = BFTX_EncodeRequest{} }
func (m *BFTX_EncodeRequest) String() string            { return proto.CompactTextString(m) }
func (*BFTX_EncodeRequest) ProtoMessage()               {}
func (*BFTX_EncodeRequest) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0} }

func (m *BFTX_EncodeRequest) GetBftxtrans() *BFTXTransaction {
	if m != nil {
		return m.Bftxtrans
	}
	return nil
}

func (m *BFTX_EncodeRequest) GetBftxconfig() *BFTXEncryptionConfig {
	if m != nil {
		return m.Bftxconfig
	}
	return nil
}

// The BFTX decryption transaction data structure (test version)
type BFTX_DecodeRequest struct {
	Bftxtrans *BFTXTransaction `protobuf:"bytes,1,opt,name=bftxtrans" json:"bftxtrans,omitempty"`
	KeyName   string           `protobuf:"bytes,2,opt,name=KeyName" json:"KeyName,omitempty"`
}

func (m *BFTX_DecodeRequest) Reset()                    { *m = BFTX_DecodeRequest{} }
func (m *BFTX_DecodeRequest) String() string            { return proto.CompactTextString(m) }
func (*BFTX_DecodeRequest) ProtoMessage()               {}
func (*BFTX_DecodeRequest) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{1} }

func (m *BFTX_DecodeRequest) GetBftxtrans() *BFTXTransaction {
	if m != nil {
		return m.Bftxtrans
	}
	return nil
}

func (m *BFTX_DecodeRequest) GetKeyName() string {
	if m != nil {
		return m.KeyName
	}
	return ""
}

type BFTXEncryptionConfig struct {
	Version          string             `protobuf:"bytes,1,opt,name=version" json:"version,omitempty"`
	Group            string             `protobuf:"bytes,2,opt,name=group" json:"group,omitempty"`
	Recipients       []string           `protobuf:"bytes,3,rep,name=recipients" json:"recipients,omitempty"`
	Encryptionfields []*ENCRYPTIONFIELD `protobuf:"bytes,4,rep,name=encryptionfields" json:"encryptionfields,omitempty"`
	Publickeys       []*PUBLICKEYS      `protobuf:"bytes,5,rep,name=publickeys" json:"publickeys,omitempty"`
}

func (m *BFTXEncryptionConfig) Reset()                    { *m = BFTXEncryptionConfig{} }
func (m *BFTXEncryptionConfig) String() string            { return proto.CompactTextString(m) }
func (*BFTXEncryptionConfig) ProtoMessage()               {}
func (*BFTXEncryptionConfig) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{2} }

func (m *BFTXEncryptionConfig) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *BFTXEncryptionConfig) GetGroup() string {
	if m != nil {
		return m.Group
	}
	return ""
}

func (m *BFTXEncryptionConfig) GetRecipients() []string {
	if m != nil {
		return m.Recipients
	}
	return nil
}

func (m *BFTXEncryptionConfig) GetEncryptionfields() []*ENCRYPTIONFIELD {
	if m != nil {
		return m.Encryptionfields
	}
	return nil
}

func (m *BFTXEncryptionConfig) GetPublickeys() []*PUBLICKEYS {
	if m != nil {
		return m.Publickeys
	}
	return nil
}

type ENCRYPTIONFIELD struct {
	Fieldname      string   `protobuf:"bytes,1,opt,name=fieldname" json:"fieldname,omitempty"`
	Authorizeduser []string `protobuf:"bytes,2,rep,name=authorizeduser" json:"authorizeduser,omitempty"`
}

func (m *ENCRYPTIONFIELD) Reset()                    { *m = ENCRYPTIONFIELD{} }
func (m *ENCRYPTIONFIELD) String() string            { return proto.CompactTextString(m) }
func (*ENCRYPTIONFIELD) ProtoMessage()               {}
func (*ENCRYPTIONFIELD) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{3} }

func (m *ENCRYPTIONFIELD) GetFieldname() string {
	if m != nil {
		return m.Fieldname
	}
	return ""
}

func (m *ENCRYPTIONFIELD) GetAuthorizeduser() []string {
	if m != nil {
		return m.Authorizeduser
	}
	return nil
}

type PUBLICKEYS struct {
	Userid  string `protobuf:"bytes,1,opt,name=userid" json:"userid,omitempty"`
	Keyfile string `protobuf:"bytes,2,opt,name=keyfile" json:"keyfile,omitempty"`
}

func (m *PUBLICKEYS) Reset()                    { *m = PUBLICKEYS{} }
func (m *PUBLICKEYS) String() string            { return proto.CompactTextString(m) }
func (*PUBLICKEYS) ProtoMessage()               {}
func (*PUBLICKEYS) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{4} }

func (m *PUBLICKEYS) GetUserid() string {
	if m != nil {
		return m.Userid
	}
	return ""
}

func (m *PUBLICKEYS) GetKeyfile() string {
	if m != nil {
		return m.Keyfile
	}
	return ""
}

func init() {
	proto.RegisterType((*BFTX_EncodeRequest)(nil), "bfimports.BFTX_Encode_request")
	proto.RegisterType((*BFTX_DecodeRequest)(nil), "bfimports.BFTX_Decode_request")
	proto.RegisterType((*BFTXEncryptionConfig)(nil), "bfimports.BFTX_encryptionConfig")
	proto.RegisterType((*ENCRYPTIONFIELD)(nil), "bfimports.ENCRYPTIONFIELD")
	proto.RegisterType((*PUBLICKEYS)(nil), "bfimports.PUBLICKEYS")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for BFSaberService service

type BFSaberServiceClient interface {
	// request a service of encryption
	BFTX_Encode(ctx context.Context, in *BFTX_EncodeRequest, opts ...grpc.CallOption) (*BFTXTransaction, error)
	// request a service for decryption
	BFTX_Decode(ctx context.Context, in *BFTX_DecodeRequest, opts ...grpc.CallOption) (*BFTXTransaction, error)
}

type bFSaberServiceClient struct {
	cc *grpc.ClientConn
}

func NewBFSaberServiceClient(cc *grpc.ClientConn) BFSaberServiceClient {
	return &bFSaberServiceClient{cc}
}

func (c *bFSaberServiceClient) BFTX_Encode(ctx context.Context, in *BFTX_EncodeRequest, opts ...grpc.CallOption) (*BFTXTransaction, error) {
	out := new(BFTXTransaction)
	err := grpc.Invoke(ctx, "/bfimports.BFSaberService/BFTX_Encode", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bFSaberServiceClient) BFTX_Decode(ctx context.Context, in *BFTX_DecodeRequest, opts ...grpc.CallOption) (*BFTXTransaction, error) {
	out := new(BFTXTransaction)
	err := grpc.Invoke(ctx, "/bfimports.BFSaberService/BFTX_Decode", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for BFSaberService service

type BFSaberServiceServer interface {
	// request a service of encryption
	BFTX_Encode(context.Context, *BFTX_EncodeRequest) (*BFTXTransaction, error)
	// request a service for decryption
	BFTX_Decode(context.Context, *BFTX_DecodeRequest) (*BFTXTransaction, error)
}

func RegisterBFSaberServiceServer(s *grpc.Server, srv BFSaberServiceServer) {
	s.RegisterService(&_BFSaberService_serviceDesc, srv)
}

func _BFSaberService_BFTX_Encode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BFTX_EncodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BFSaberServiceServer).BFTX_Encode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bfimports.BFSaberService/BFTX_Encode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BFSaberServiceServer).BFTX_Encode(ctx, req.(*BFTX_EncodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BFSaberService_BFTX_Decode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BFTX_DecodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BFSaberServiceServer).BFTX_Decode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bfimports.BFSaberService/BFTX_Decode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BFSaberServiceServer).BFTX_Decode(ctx, req.(*BFTX_DecodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _BFSaberService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "bfimports.BFSaberService",
	HandlerType: (*BFSaberServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "BFTX_Encode",
			Handler:    _BFSaberService_BFTX_Encode_Handler,
		},
		{
			MethodName: "BFTX_Decode",
			Handler:    _BFSaberService_BFTX_Decode_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "saberservice.proto",
}

func init() { proto.RegisterFile("saberservice.proto", fileDescriptor1) }

var fileDescriptor1 = []byte{
	// 426 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x93, 0xcf, 0x6e, 0xd3, 0x40,
	0x10, 0xc6, 0x71, 0x43, 0x8b, 0x3c, 0x91, 0x0a, 0xda, 0x52, 0x64, 0x05, 0x54, 0x59, 0x3e, 0xa0,
	0x9c, 0x72, 0x08, 0xe2, 0xc0, 0x05, 0x21, 0xa7, 0xb6, 0x14, 0x35, 0x0a, 0xd5, 0xa6, 0x08, 0x7a,
	0xaa, 0xfc, 0x67, 0x5c, 0x96, 0xa6, 0xbb, 0x66, 0x77, 0x5d, 0x61, 0x1e, 0x83, 0xe7, 0xe0, 0xb9,
	0x78, 0x0e, 0xe4, 0xb5, 0x1b, 0x3b, 0x0e, 0x82, 0x0b, 0xc7, 0x6f, 0xbc, 0xdf, 0x6f, 0x66, 0x76,
	0x3f, 0x03, 0x51, 0x51, 0x8c, 0x52, 0xa1, 0xbc, 0x63, 0x09, 0x4e, 0x72, 0x29, 0xb4, 0x20, 0x76,
	0x9c, 0xb1, 0xdb, 0x5c, 0x48, 0xad, 0x46, 0x47, 0x7e, 0xa6, 0x65, 0xc4, 0x55, 0x94, 0x68, 0x26,
	0x78, 0xfd, 0xdd, 0xfb, 0x61, 0xc1, 0x91, 0x1f, 0x5e, 0x7c, 0xba, 0x0a, 0x78, 0x22, 0x52, 0xbc,
	0x92, 0xf8, 0xb5, 0x40, 0xa5, 0xc9, 0x1b, 0xb0, 0xe3, 0x4c, 0x7f, 0x33, 0x06, 0xc7, 0x72, 0xad,
	0xf1, 0x70, 0xfa, 0x7c, 0xb2, 0x61, 0x4d, 0x8c, 0xa5, 0x43, 0xa3, 0xed, 0x69, 0xf2, 0x0e, 0xa0,
	0x12, 0x89, 0xe0, 0x19, 0xbb, 0x76, 0xf6, 0x8c, 0xd7, 0xed, 0x7b, 0x91, 0x27, 0xb2, 0xcc, 0x2b,
	0xeb, 0xcc, 0x9c, 0xa3, 0x1d, 0x8f, 0xf7, 0xa5, 0x99, 0xe9, 0x14, 0xff, 0xd7, 0x4c, 0x0e, 0x3c,
	0x3a, 0xc3, 0x72, 0x19, 0xdd, 0xa2, 0x19, 0xc8, 0xa6, 0xf7, 0xd2, 0xfb, 0x65, 0xc1, 0xf1, 0x1f,
	0x27, 0xaa, 0x3c, 0x77, 0x28, 0x15, 0x13, 0xdc, 0x34, 0xb3, 0xe9, 0xbd, 0x24, 0x4f, 0x61, 0xff,
	0x5a, 0x8a, 0x22, 0x6f, 0x58, 0xb5, 0x20, 0x27, 0x00, 0x12, 0x13, 0x96, 0x33, 0xe4, 0x5a, 0x39,
	0x03, 0x77, 0x30, 0xb6, 0x69, 0xa7, 0x42, 0x42, 0x78, 0xd2, 0xf6, 0xc8, 0x18, 0xae, 0x53, 0xe5,
	0x3c, 0x74, 0x07, 0xe3, 0xe1, 0x74, 0xd4, 0xd9, 0x22, 0x58, 0xce, 0xe8, 0xe5, 0xf9, 0xc5, 0xfc,
	0xfd, 0x32, 0x9c, 0x07, 0x8b, 0x53, 0xba, 0xe3, 0x21, 0xaf, 0x01, 0xf2, 0x22, 0x5e, 0xb3, 0xe4,
	0x06, 0x4b, 0xe5, 0xec, 0x1b, 0xc2, 0x71, 0x87, 0x70, 0xfe, 0xc1, 0x5f, 0xcc, 0x67, 0x67, 0xc1,
	0xe5, 0x8a, 0x76, 0x0e, 0x7a, 0x1f, 0xe1, 0x71, 0x8f, 0x4d, 0x5e, 0x80, 0x6d, 0x98, 0xbc, 0xba,
	0x97, 0x7a, 0xc7, 0xb6, 0x40, 0x5e, 0xc2, 0x61, 0x54, 0xe8, 0xcf, 0x42, 0xb2, 0xef, 0x98, 0x16,
	0x0a, 0xa5, 0xb3, 0x67, 0x76, 0xea, 0x55, 0xbd, 0xb7, 0x00, 0x6d, 0x4b, 0xf2, 0x0c, 0x0e, 0xaa,
	0x2a, 0x4b, 0x1b, 0x60, 0xa3, 0xaa, 0xdb, 0xbc, 0xc1, 0x32, 0x63, 0xeb, 0xcd, 0x0b, 0x34, 0x72,
	0xfa, 0xd3, 0x82, 0x43, 0x3f, 0x5c, 0x55, 0xd9, 0x5d, 0xd5, 0xd9, 0x25, 0x0b, 0x18, 0x76, 0x42,
	0x49, 0x4e, 0xfa, 0xaf, 0xbc, 0x1d, 0xd6, 0xd1, 0xdf, 0x52, 0xe0, 0x3d, 0xd8, 0xd0, 0xea, 0x38,
	0xed, 0xd2, 0xb6, 0x63, 0xf6, 0x0f, 0x5a, 0x7c, 0x60, 0x7e, 0x9c, 0x57, 0xbf, 0x03, 0x00, 0x00,
	0xff, 0xff, 0x80, 0x4f, 0x7a, 0x88, 0x6e, 0x03, 0x00, 0x00,
}
